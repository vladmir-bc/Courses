##########################################################################
?iris
df <- iris

str(df)

df1 <- subset(df, Species != "setosa")
str(df1)
table(df1$Species)  # показывает количество, относящееся к каждому фактору
##########################################################################

# Построим несколько графиков, чтобы посмотреть, как распределена наша перменная

hist(df1$Sepal.Length)  # распределение довольно симметричное

# Хотелось бы также построить гистограмму отдельно для каждой из групп
# Можно это сделать также через hist, но более предпочтительно через ggplot

library(ggplot2)

ggplot(df1, aes(x = Sepal.Length))+
  geom_histogram(fill = "white", col = "black", binwidth = 0.4)+
  facet_grid(Species ~ .)  # позволяет добавить некоторую переменную, которая разобьет наблюдение на группы


ggplot(df1, aes(Sepal.Length, fill = Species))+
  geom_density(alpha = 0.5)  # график, который рисует функцию плотности (alpha - уровень прозрачности)

ggplot(df1, aes(Species, Sepal.Length))+  # полезно посмотреть, есть ли выбросы в наших группах
  geom_boxplot()  # межквартильный размах примерно одинаковый, но в группе №2 есть выброс
##########################################################################

# мы увидели, что распределение довольно симметричное, а также на графиках видны различия по количественной переменной

# теперь мы хотим посмотреть при помощи t-теста, насколько эти различия статистически значимы
# однако стоит проверять ограничения: нормальность распределения и гомогенность дисперсий (дисперсии внутри групп примерно одинаковые)

# убедимся, что замеченные отклонения не столь критичны: проверим тестом Шапиро

shapiro.test(x = df1$Sepal.Length)  # в качестве аргумента принимается вектор значений
# p-value > 0.05, значит распределение не отличается от нормального

shapiro.test(df1$Sepal.Length[df1$Species == "versicolor"])
shapiro.test(df1$Sepal.Length[df1$Species == "virginica"])


# теперь проверим гомогенность дисперсий

# критерий Барлетта
bartlett.test(Sepal.Length ~ Species, df1)  # получим результат, сравнение дисперсий в двух группах
##########################################################################

# выполним t-тест

t.test(Sepal.Length ~ Species, df1)  # мы хотим разбить количственную переменную по факторной переменной, и все это происходит в данных df1
test1 <- t.test(Sepal.Length ~ Species, df1)

str(test1)
test1$p.value  # можем обратиться только к p-значению
##########################################################################

# важный момент, если мы обратимся не к df1, а к df, то будет ошибка
# т.к. группирующий фактор должен иметь 2 уровня, а не 3
t.test(Sepal.Length ~ Species, df1, var.equal = T)  # добавили учет гомогенности дисперсий. По умолчанию t-тест выполняется без учета равенства дисперсий
?t.test()

# если мы хотим использовать t-тест для одновыборочного теста и сравнить среднее значение по количественной переменной
mean(df1$Sepal.Length)  # 6.262
t.test(df1$Sepal.Length, mu = 8)  # отклонили H0 о том, что среднее в генеральной совокупности == 8
##########################################################################

# также мы можем использовать t-тест для сравнения зависимых выборок
# давайте проверим гипотезу о том, что длина и ширина лепестка на самом деле не равны (H0 - эти показатели равняются в ГС)

t.test(df1$Petal.Length, df1$Petal.Width, paired = T)  # требуется 2 вектора значений: длина лепестка и ширина лепестка
# также важно указать, что мы будем работать с зависимыми выборками через аргумент paired
##########################################################################

# визуализируем данные: т.е. на графике построить два средних значения, доверительные интервалы
library(ggplot2)

ggplot(df1, aes(Species, Sepal.Length))+
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar")
##########################################################################

# поработаем над графиком
library(ggplot2)

ggplot(df1, aes(Species, Sepal.Length))+
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0.1)+
  stat_summary(fun.y = mean, geom = "point", size = 4)  # добавим новый слой для отображения средних значений

# еще один вариант добавления средних без реализации дополнительного слоя:
ggplot(df1, aes(Species, Sepal.Length))+
  stat_summary(fun.data = mean_cl_normal, geom = "pointrange", size = 1)
##########################################################################

?wilcox.test()

test2 <- wilcox.test(Petal.Length ~ Species, df1)  # проверим, различается ли длина лепестка по виду цветка
# мы видим, что данные статистически значимо разлючаются м/у двумя видами
test2$statistic

# если мы сделали непараметрический тест, то логично построить непараметрический график

ggplot(df1, aes(Species, Petal.Length))+
  geom_boxplot()


# также у критерия Вилконсона есть дополнительные параметры
wilcox.test(df1$Petal.Length, df1$Petal.Width, paired = T)  # применим для двух зависимых выборок

##########################################################################

df1 <- read.table("dataset_11504_16.txt")

t.test(df1$V1, df1$V2)
